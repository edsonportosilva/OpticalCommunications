# -*- coding: utf-8 -*-
"""MZM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18AEDd9SJElzIIpTmA1Rm5mIvI9sFSfpS

# Comunicações ópticas
"""

import numpy as np
import matplotlib.pyplot as plt

from IPython.display import display, Math
from IPython.display import display as disp

from IPython.core.display import HTML
from IPython.core.pylabtools import figsize

HTML("""
<style>
.output_png {
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}
</style>
""")

figsize(10, 3)

plt.style.use('seaborn-v0_8-darkgrid')

"""## Parâmetros do MZM

O sinal óptico na saída do MZM é:

\begin{align}
E_{out}(t) &= \frac{E_{in}(t)}{2}e^{j\phi_1(t)} + \frac{E_{in}(t)}{2}e^{j\phi_2(t)} \\
&= E_{in}(t)\cos\left( \frac{u(t)}{2V_{\pi}}\pi \right)
\end{align}

A transmitância, obtida a partir da relação das intensidades de campo elétrico, é:

\begin{equation}
\frac{\left| E_{out}(t) \right|^2}{\left| E_{in}(t) \right|^2} = \frac{P_{out}(t)}{P_{in}(t)} = \frac{1}{2} + \frac{1}{2} \cos\left( \frac{u(t)}{V_{\pi}}\pi \right)
\end{equation}
"""

def MZM(V, Vdc, Vpi):
  return (np.cos(np.pi/2*(V+Vdc)/Vpi))

Vmax = 2
Vmin = -2
V = np.linspace(Vmin, Vmax, 100)

Vpi = 1
Vdc = 0

fig1 = plt.figure()
plt.plot(V, MZM(V, Vdc, Vpi), label = 'Field')
plt.plot(V, np.abs(MZM(V, Vdc, Vpi))**2, label = 'Power')
plt.plot(0, np.abs(MZM(0, Vdc, Vpi))**2, 'sr')
plt.plot(Vpi, np.abs(MZM(Vpi, Vdc, Vpi))**2, 'sr')
plt.xlabel(r'$V/V_\pi$')
plt.ylabel('Transmissão')
plt.xlim([Vmin, Vmax])
plt.grid(True)

Vdc = -Vpi

fig2 = plt.figure()
plt.plot(V, MZM(V, Vdc, Vpi), linewidth = 2, label = 'Field')
plt.plot(V, np.abs(MZM(V, Vdc, Vpi))**2, linewidth = 2, label = 'Power')
plt.plot(0, np.abs(MZM(0, Vdc, Vpi))**2, 'sr')
plt.plot(Vpi, np.abs(MZM(Vpi, Vdc, Vpi))**2, 'sr')
plt.xlabel(r'$V/V_\pi$')
plt.ylabel('Transmissão')
plt.xlim([Vmin, Vmax])
plt.grid(True)

"""## Sinal modulante"""

!pip install OptiCommPy

from commpy.utilities  import signal_power, upsample
from optic.dsp import firFilter, pulseShape
from optic.plot import eyediagram

# parâmetros da simulação
SpS = 32

Rs  = 10e9          # Taxa de símbolos (para o caso do OOK Rs = Rb)
Ts  = 1/Rs          # Período de símbolo em segundos
Fa  = 1/(Ts/SpS)    # Frequência de amostragem do sinal (amostras/segundo)
Ta  = 1/Fa          # Período de amostragem
P0  = 1             # Potência

# gera sequência de bits pseudo-aleatórios
bits   = np.random.randint(2, size=20)    
n      = np.arange(0, bits.size)
# mapeia bits para símbolos OOK
symbTx = np.sqrt(P0)*bits
# upsampling
symbolsUp = upsample(symbTx, SpS)
# pulso retangular ideal
pulse = pulseShape('rect', SpS)
pulse = pulse/max(abs(pulse))
#formatação de pulso retangular
sigTx  = firFilter(pulse, symbolsUp)
# plota sinal 
t = np.arange(0, sigTx.size)*(Ta/1e-12)
# instantes centrais dos intervalos de sinalização
symbolsUp = upsample(2*bits-1, SpS)
symbolsUp[symbolsUp==0] = np.nan
symbolsUp = (symbolsUp + 1)/2

fig, axs = plt.subplots(1,2)
axs[0].stem(symbTx, basefmt=" ", use_line_collection=True)
axs[0].set_xlabel('n')
axs[0].set_ylabel('$b_n$')
axs[0].grid(True)

axs[1].plot(t, sigTx.real,'-', linewidth=3)
axs[1].plot(t, symbolsUp.real, 'o')
axs[1].set_xlabel('Tempo [ps]')
axs[1].set_ylabel('amplitude')
axs[1].grid(True)

fig1

Vpi  = 1
Vdc  = 0

plt.figure()
plt.plot(t, np.abs(MZM(sigTx.real, Vdc, Vpi))**2, linewidth = 2, label = 'Power')
plt.xlabel('tempo [ps]')
plt.ylabel('amplitude')
plt.grid(True)

Vpi  = 1
Vdc  = -Vpi

fig2

plt.figure()
plt.plot(t, np.abs(MZM(sigTx.real, Vdc, Vpi))**2, linewidth = 2, label = 'Power')
plt.xlabel('tempo [ps]')
plt.ylabel('amplitude')
plt.grid(True)

Vpi  = 1
Vdc  = -Vpi/2

fig3 = plt.figure()
plt.plot(V, MZM(V, Vdc, Vpi), linewidth = 2, label = 'Field')
plt.plot(V, np.abs(MZM(V, Vdc, Vpi))**2, linewidth = 2, label = 'Power')
plt.plot(0, np.abs(MZM(0, Vdc, Vpi))**2, 'sr')
plt.plot(Vpi, np.abs(MZM(Vpi, Vdc, Vpi))**2, 'sr')
plt.xlabel(r'$V/V_\pi$')
plt.ylabel('Transmissão')
plt.xlim([Vmin, Vmax])
plt.grid(True)

plt.figure()
plt.plot(t, np.abs(MZM(sigTx.real, Vdc, Vpi))**2, linewidth = 2, label = 'Power')
plt.xlabel('tempo [ps]')
plt.ylabel('amplitude')
plt.grid(True)

"""## Limitação em frequência

Considere que a resposta do driver ou modulado em frequência é limitado.
"""

# upsampling
symbolsUp = upsample(symbTx, SpS)
# pulso retangular ideal
pulse = pulseShape('nrz', SpS)
pulse = pulse/max(abs(pulse))
#formatação de pulso retangular
sigTx_nrz  = firFilter(pulse, symbolsUp)
# instantes centrais dos intervalos de sinalização
symbolsUp = upsample(2*bits-1, SpS)
symbolsUp[symbolsUp==0] = np.nan
symbolsUp = (symbolsUp + 1)/2

fig, axs = plt.subplots(1,2)
axs[0].stem(symbTx, basefmt=" ", use_line_collection=True)
axs[0].set_xlabel('n')
axs[0].set_ylabel('$b_n$')
axs[0].grid(True)

axs[1].plot(t, sigTx_nrz.real,'-', linewidth=3)
axs[1].plot(t, symbolsUp.real, 'o')
axs[1].set_xlabel('tempo [ps]')
axs[1].set_ylabel('amplitude')
axs[1].grid(True)

Vpi  = 1
Vdc  = -Vpi

fig2

plt.figure()
plt.plot(t, np.abs(MZM(sigTx_nrz.real, Vdc, Vpi))**2, linewidth = 2, label = 'Power')
plt.xlabel('tempo [ps]')
plt.ylabel('amplitude')
plt.grid(True)

Vpi  = 1
Vdc  = -Vpi/2

fig3

plt.figure()
plt.plot(t, np.abs(MZM(sigTx_nrz.real, Vdc, Vpi))**2, linewidth = 2, label = 'Power')
plt.xlabel('tempo [ps]')
plt.ylabel('amplitude')
plt.grid(True)